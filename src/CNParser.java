
	
	   import java.io.File;
	   import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Iterator;
	   import java.util.Scanner;
import java.util.ArrayList;


/**
 * 
 * The CNParser takes a .bcn textfile and parses it. It stores all the data into an intermediary Node class that holds all the information
 * in arrays. After all the parsing is done, the CSP gets generated by querying the Node.
 * 
 * It outputs a CSP object that can be solved or written again.
 * 
 * @author adnan
 *
 */
	   public class CNParser {

		   public static Node[] nodes;
	     
		   private static int process(ArrayList<String> information) {
			   
			   int number_of_nodes;
			   
			   //get the number of nodes
				   if(information.get(0).contains("#_of_nodes")) {
					   String[] tokens = information.get(0).split("\\s");
					   number_of_nodes = Integer.parseInt(tokens[0]);
				   }
				   else 
					   return 1; //error
			
				   //create the nodes to store all the information
				   nodes = new Node[number_of_nodes]; 
				   
				   System.out.println("Number of nodes: " + number_of_nodes);
				   
				int j = 2, iptr = 0;  
				
				for(int i = 0; i < number_of_nodes; i++) {
					nodes[i] = new Node();
				   //for(j = iptr; j < information.size(); j++) {
//System.out.format("LINE: (i = %d, j = %d) = %s\n", i, j, information.get(j));
							if(information.get(j).equals("")) 
						   		j++;

						   //System.out.println("Parsing...");
						   int numstates = 0;
						   int numconstraints = 0;
						   if(information.get(j).contains("#_of_states_var_")) {
							   numstates = Integer.parseInt(information.get(j).split("\\s+")[0]);
							   nodes[i].varNum = i;
							   j++;
						   }
//System.out.println("numstates: " + numstates + ", get(j) = " + information.get(j));
						   if(information.get(j).contains("node_label")) {
							   //add the node label
//System.out.println(information.get(j).split("\\s")[0]);
							   nodes[i].label = information.get(j).split("\\s+")[0];
							   j++;
							   //add the node's domain
							   String[] domain = new String[numstates];
							   for(int k = 0; k < numstates; k++, j++) {
								   domain[k] = new String(information.get(j));
//System.out.println(domain[k]);
							   }
							   //add the domain to the node
							   nodes[i].domain = domain;
						   }
						   // Set adj list
//System.out.println(information.get(j));			
						   if(information.get(j).contains("neighbor")) {
							   String adjlist[] = information.get(j).split("\\s+");
							   int numneighbors = Integer.parseInt(adjlist[0]);

//for(int x = 0; x < adjlist.length; x++)
   //System.out.format("adjlist[%d] = %s\n",x, adjlist[x]);
								
							   int n = 0;

								int[] adj = new int[numneighbors];
								for(int a = 1; a < adjlist.length-1; a++) {
	//System.out.println(adjlist[a]);							
								   //if(!adjlist[a].equals("")) {
									   adj[n] = Integer.parseInt(adjlist[a]);
//System.out.format("adj[%d] = %d\n", n, Integer.parseInt(adjlist[a]));
									   n++;
								   //}
							   }
							   //add the neighbors to the node
							   nodes[i].adj = adj;
							   j++;
						   }
						   if(information.get(j).contains("#constraints_stored")) {
//System.out.println(information.get(j));		
							   numconstraints = Integer.parseInt(information.get(j).split("\\s+")[0]);
							   j++;
							   System.out.println("numconstraints: " + numconstraints);		
							   //Get the constraints
							   ArrayList<ArrayList<Integer>> constraintTable = new ArrayList<ArrayList<Integer>>();
							   for(int k = 0; k < numconstraints; k++) {
//System.out.println("k:" + k + " " + information.get(j));	
								   if(information.get(j).contains("nb/#legal_config")) {
									   String line[] = information.get(j).split("\\s+");
//for(int x = 0; x < line.length; x++)
	//System.out.format("line[%d] = %s\n",x, line[x]);
									   int neighbour = Integer.parseInt(line[0]);
									   int numassignments = Integer.parseInt(line[1]);
									   j++;
									   int c = 0, n = 0;
									   
									   //int tmp[][] = new int[numassignments][1];
									   //tmp[0][0] = 0;
									   
									   
									   //parse the constraints
									   while(n < numassignments) {
										   String constraints[] = information.get(j).split("[;\\s]+");
//for(int x = 0; x < constraints.length; x++)
	//System.out.format("constraints[%d] = %s\n",x, constraints[x]);
										   for(c = 0; c < constraints.length / 2; c++, n++) {
											   ArrayList<Integer> neighbourConstraint = new ArrayList<Integer>(3);
											   neighbourConstraint.add(neighbour);
											   neighbourConstraint.add(Integer.parseInt(constraints[c*2]));
											   neighbourConstraint.add(Integer.parseInt(constraints[c*2+1]));
											   constraintTable.add(neighbourConstraint);
										   }
										   
											//go to the next line for remaining constraints
//System.out.println("c = " + c);				c = 0;							
										   j++;
										   //n++;
									   }
									   
								   }
								   //store constraint table into node
								   nodes[i].constraints = constraintTable;
								   //j++;
							   }
							   //j++;
							  
						   }
//System.out.format("j = %d, get(j) = %s\n", j, information.get(j));
						   if(information.get(j).contains("Coordinate")) {
							   
							   String[] coords = information.get(j).split("\\s+");
//for(String s: coords)
//System.out.println("Coords: " + s);							   
							   int coordinates[] = new int[2];
							   coordinates[0] = Integer.parseInt(coords[0]);
							   coordinates[1] = Integer.parseInt(coords[1]);
							   nodes[i].coordinates = coordinates;
							   //nodes[i].coordinates[0] = Integer.parseInt(coords[0]);
							   //nodes[i].coordinates[1] = Integer.parseInt(coords[1]);  
							   j++;
						   }
						   if(j >= information.size()) {//EOF reached
							   System.out.println("EOF reached");
							   break;
						   }
						   
//System.out.format("i=%d, j=%d\n", i, j);		   
							   
					   }
				  
				return 0; //OK
			   }
		   
		   
		   /**
		    * Method that read the file.
		    * 
		    * @param fileName - The file name of the .bcn file.
		    * @return
		    */
		   private static ArrayList<String> readFile(String fileName) {
	       
	    	 ArrayList<String> arr = new ArrayList<String>();
	    	 
	    	try {
	         File file = new File(fileName);
	         Scanner scanner = new Scanner(file);
	         
	         while (scanner.hasNext()) {
	           arr.add(scanner.nextLine());
	         }
	         scanner.close();
	       } catch (FileNotFoundException e) {
	         e.printStackTrace();
	       }
	       
	       return arr;
	       
	     }
/**
 * The method that calls the parser and then converts the intermediary Node class into a CSP and returns a CSP
 * 
 * @param parseFile - the file that is to be parsed
 * @return a CSP
 */
		   public static CSP parse(String parseFile) {
	       
	       
	       if(process(readFile(parseFile)) != 0) {
	    	   System.out.println("Failure on reading file");
	    	   return null;
	       }
	       else
	    	   System.out.println("Parsing Successful");
	       
	       //print all the node attributes
	       for(int x = 0; x < nodes.length; x++) {
	    	   System.out.format("NODE[%d]: varnum = %d, label = %s\n", x, nodes[x].varNum, nodes[x].label);
	    	   for(int y = 0; y < nodes[x].domain.length; y++){
	    		   System.out.format("domain[%d] = %s\n", y, nodes[x].domain[y]);
	    	   }
	    	   if(nodes[x].adj != null) {
	    	   for(int y = 0; y < nodes[x].adj.length; y++){
	    		   System.out.format("adj[%d] = %d\n", y, nodes[x].adj[y]);
	    	   }
	    	   }
	    	   if(nodes[x].constraints != null) {
	    	   for(ArrayList<Integer> vector: nodes[x].constraints){
	    			   	System.out.format("constraint = (%d, (%d, %d))\n", vector.get(0), vector.get(1), vector.get(2));  
	    	   }
	    	   }
	    	   System.out.format("Coords[%d] = (%d, %d)\n", x, nodes[x].coordinates[0], nodes[x].coordinates[1]);
	    	   
	       }
	       	     
	     //Create nodes based on the CN network above
	        Graph G = new Graph();
	        
	        //Create domain table [(Vertex, Domain)]
	        ST<String, SET<String>> domainTable = new ST<String, SET<String>>();
	        
	      //create the constraints table [(Vertex, (Neighbour, (Domain value, Valid Assignments)))]
	        ST<String, ST<String, ST<String, SET<String>>>> constraintsTable = new ST<String, ST<String, ST<String, SET<String>>>>();
	        
	        //create the coordinates table
	        ST<String, ArrayList<Integer>> coordinatesTable = new ST<String, ArrayList<Integer>>();
	        
	        int ccount = 0;
	        
	        for(int n = 0; n < nodes.length; n++) {
	        	//add vertex
	        	//G.addVertex(nodes[n].label);
	        	
	        	//add vertices and edges
	        	for(int nadj = 0; nadj < nodes[n].adj.length; nadj++){
	        		G.addEdge(nodes[n].label, nodes[nodes[n].adj[nadj]].label);
	        	}
	        	
	        	//System.out.println(G);
	        	
		        //build the domain table
	        	SET<String> domain = new SET<String>();
	        	for(int ndom = 0; ndom < nodes[n].domain.length; ndom++){
	        		domain.add(nodes[n].domain[ndom]);
	        	}
	        	
	        	//put the node's domain in the domain table
	        	domainTable.put(nodes[n].label, domain);
	        	
	        	//build the constraints table
	        	SET<String> setOfConstraints = new SET<String>();
	        	//setOfConstraints.add();
	        	
	        	int c;
	        	ArrayList<Integer> vector;
	        	ST<String, ST<String, SET<String>>> currentNeighbourConstraint = new ST<String, ST<String, SET<String>>>();
	        	for(c = 0; nodes[n].constraints != null && c < nodes[n].constraints.size(); c++) {
	        		//System.out.format();
	        		vector = nodes[n].constraints.get(c);
	        		int currentNeighbour = vector.get(0);
	        		//while the neighbbour is the same
	        		ST<String, SET<String>> currentConstraint = new ST<String, SET<String>>();
	        		while(vector.get(0) == currentNeighbour) {
	        			System.out.println(vector.get(0)+ " = " + currentNeighbour);
	        			//while value is the same
	        			int currentValue = vector.get(1);
	        			int limit = 0;
	        			SET<String> currentSetOfConstraints = new SET<String>();
	        			while((vector.get(0) == currentNeighbour) && (vector.get(1) == currentValue)) {
	        				System.out.format("(%d, (%d, %d)\n", currentNeighbour, currentValue, vector.get(2));
	        				currentSetOfConstraints.add(nodes[currentNeighbour].domain[vector.get(2)]);
	        				ccount++;
	        				c++; //next
	        				int sizeofconstraints = nodes[n].constraints.size();
	        				if(c >= sizeofconstraints) {
	        					limit = 1;
	        					break;
	        				}
	        				vector = nodes[n].constraints.get(c);
	        			}
	        			currentConstraint.put(nodes[n].domain[currentValue], currentSetOfConstraints);
	        			if(limit == 1) {
	        				break;
	        			}
	        		}
	        		
        			currentNeighbourConstraint.put(nodes[currentNeighbour].label, currentConstraint);
	        	
	        	}
	        	constraintsTable.put(nodes[n].label, currentNeighbourConstraint);
	        	
	        	//Put in the coordinates
	        	ArrayList<Integer> coords = new ArrayList<Integer>();
	        	coords.add(nodes[n].coordinates[0]);
	        	coords.add(nodes[n].coordinates[1]);
	        	coordinatesTable.put(nodes[n].label, coords);
	        }
	        
	        /*
        	System.out.println("constraintsTable.length: " + constraintsTable.size());
        	System.out.println("ccount: " + ccount);
        	*/
	        
        	//print constraints Table ST<String, ST<String, ST<String, SET<String>>>> 
        	/*int m = 0;
        	for(String x: constraintsTable) {
	        	for(String y: constraintsTable.get(x)) {
		        	for(String z: (constraintsTable.get(x)).get(y)) {
		        		m++;
		        		System.out.format("(%s, (%s, (%s, (%s))))\n", x, y, z, ((constraintsTable.get(x)).get(y)).get(z).toString());
		        	}
		        	System.out.println("--------------------------------------------");
		        	//break;
	        	}
	        	System.out.println("--------------------------------------------");
	        	//break;
        	}
        	
        	System.out.println("m: " + m);
        	*/
        	
        	//print out the file
        	CSP csp = new CSP();
        	
        	csp.G = G;
        	csp.constraintsTable = constraintsTable;
        	csp.domainTable = domainTable;
        	csp.coordinatesTable = coordinatesTable;
        	csp.vIndex = new ST<String, Integer>();
        	csp.dIndex = new ST<String, ST<String, Integer>>();
        	
    		//First, index all the vertices and domain values for each vertex to print them out
    		
        	
        	//TODO: This is not correct...Index needs to correspond to the actua lindex of the input file
        	
    		//Vertex index 
    		int vcount = 0;
    		//ST<String, Integer> vIndex = new ST<String, Integer>(); 
    		for(String node: csp.G.vertices()) {
    			csp.vIndex.put(node, vcount);
    			vcount++;
    		}
    		//Domain value index
    		for(String node: csp.G.vertices()) {
    			ST<String, Integer> tmpIndex = new ST<String, Integer>();
    			int dcount = 0;
    			for(String d: csp.domainTable.get(node)) {
    				tmpIndex.put(d, dcount);
    				dcount++;
    			}
    			csp.dIndex.put(node, tmpIndex);
    		}
			
			return csp;
			
	
	     }  
}
